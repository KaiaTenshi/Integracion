<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rival Más Débil — Evento Competitivo</title>
<style>
:root{--bg:#0b1220;--card:#0f1724;--accent:#7dd3fc;--accent2:#60a5fa;--muted:#94a3b8;color-scheme:dark}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#031026 0%,#071022 100%);color:#e6eef6;display:flex;align-items:center;justify-content:center;padding:20px}
.container{width:100%;max-width:1100px;background:var(--card);border-radius:12px;padding:22px;box-shadow:0 8px 30px rgba(2,6,23,.6)}
h1{margin:0 0 8px;font-size:22px;color:var(--accent)}
p.lead{margin:0 0 18px;color:var(--muted)}
.row{display:flex;gap:16px;flex-wrap:wrap}
.card{background:rgba(255,255,255,0.03);padding:14px;border-radius:10px;flex:1;min-width:280px}
button{background:linear-gradient(90deg,var(--accent),var(--accent2));border:none;padding:8px 12px;border-radius:8px;color:#042029;font-weight:700;cursor:pointer}
button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);font-weight:600}
ul.participants{list-style:none;padding:0;margin:0}
ul.participants li{padding:10px 8px;border-bottom:1px dashed rgba(255,255,255,0.03);display:flex;align-items:center;gap:12px}
.badge{padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.04);font-weight:700}
.small{font-size:13px;color:var(--muted)}
.notice{background:rgba(0,0,0,0.25);padding:10px;border-radius:8px;margin-bottom:12px;color:var(--muted)}
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:60}
.modal{background:#071028;padding:18px;border-radius:12px;min-width:320px;max-width:92%}
.progress-wrap{width:220px;background:rgba(255,255,255,0.03);border-radius:999px;padding:6px}
.progress{height:10px;border-radius:999px;background:rgba(255,255,255,0.08);overflow:hidden}
.progress > i{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--accent2))}
.part-left{flex:1;display:flex;flex-direction:column}
.part-row{display:flex;align-items:center;justify-content:space-between;gap:12px;width:100%}
.ctrls{display:flex;gap:6px}
.level-num{min-width:34px;text-align:center}
.mono{font-family:monospace}
.hidden{display:none!important}
.vote-buttons-container{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px}
.vote-btn{font-size:12px;padding:6px 10px}

/* Mejoras para dispositivos móviles */
@media (max-width: 768px) {
  body{padding:10px}
  .container{padding:16px}
  .card{min-width:100%}
  .row{flex-direction:column}
  h1{font-size:20px}
  .modal{min-width:280px;padding:14px}
  .progress-wrap{width:180px}
  .vote-buttons-container{flex-direction:column}
  .vote-btn{width:100%}
}

/* Estilos para la ventana de votación */
.vote-modal{max-width:400px;width:90%}
.vote-modal h3{margin-top:0}
.vote-modal .participant-list{max-height:300px;overflow-y:auto;margin:12px 0}
.vote-modal .participant-item{padding:10px;border-bottom:1px solid rgba(255,255,255,0.1);cursor:pointer;transition:background 0.2s}
.vote-modal .participant-item:hover{background:rgba(255,255,255,0.05)}
.vote-modal .participant-item.selected{background:rgba(125,211,252,0.1)}
.vote-modal .vote-confirm{width:100%;margin-top:12px}

/* Estilos para el aviso de eliminación */
.eliminated-notice{background:rgba(255,0,0,0.1);border:1px solid rgba(255,0,0,0.3);padding:10px;border-radius:8px;margin-top:12px}
.eliminated-notice strong{color:#ff7b7b}

/* Estilos para el control de nivel máximo */
.max-level-controls{display:flex;align-items:center;gap:8px;margin-top:8px}
.max-level-controls input{width:60px;padding:4px 8px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:4px;color:white;text-align:center}

/* Estilos para el panel de votación del moderador */
.vote-status-panel{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;margin-top:12px}
.vote-status-item{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.05)}
.vote-status-item:last-child{border-bottom:none}
.vote-status-badge{padding:2px 8px;border-radius:12px;font-size:11px;font-weight:600}
.vote-status-badge.voted{background:rgba(34,197,94,0.2);color:#4ade80}
.vote-status-badge.pending{background:rgba(251,191,36,0.2);color:#fbbf24}
.vote-checkmark{color:#4ade80;font-size:16px;margin-left:8px;}
</style>
</head>
<body>
<div class="container">
  <h1>Rival Más Débil</h1>
  <p class="lead">Sube niveles respondiendo bien. El moderador lidera las preguntas y controla niveles. Torre = 30 niveles.</p>

  <div id="status" class="notice">Conectando a Firebase...</div>

  <div class="row">
    <div class="card">
      <h3>Lobby & Participantes</h3>
      <p class="small">Máximo 1 moderador + 10 participantes. Moderador no participa en votación.</p>

      <div style="margin-top:10px">
        <button id="joinBtn" disabled>Unirme</button>
        <button id="leaveBtn" class="ghost hidden">Salir</button>
      </div>

      <div id="moderatorControls" class="hidden" style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
        <!-- Botón de inicio eliminado según solicitud -->
        <button id="startVoteBtn" class="ghost">Iniciar votación</button>
        <button id="closeGameBtn" class="ghost">Cerrar juego</button>
      </div>

      <div style="margin-top:14px">
        <h4>Participantes</h4>
        <ul id="participantsList" class="participants"></ul>
      </div>
    </div>

    <div class="card">
      <h3>Estado</h3>
      <p id="gamePhase" class="small">-</p>

      <div id="notifications" style="margin-top:12px"></div>

      <!-- Panel de estado de votación (solo para moderador) -->
      <div id="voteStatusPanel" class="vote-status-panel hidden">
        <h4>Estado de Votación - Ronda <span id="currentRoundDisplay">0</span></h4>
        <div id="voteStatusList"></div>
      </div>

      <div id="impostorNotice" class="hidden" style="margin-top:12px;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px">
        <strong id="youAre">¡Eres el rival más débil!</strong>
        <p class="small">Si te asignó el moderador, tendrás ventaja de prueba — pero el objetivo es mejorar tu nivel.</p>
      </div>

      <!-- Aviso de eliminación -->
      <div id="eliminatedNotice" class="hidden eliminated-notice">
        <strong>¡Fuiste eliminado en esta ronda!</strong>
        <p class="small">Espera a que el moderador cierre el juego para volver a participar.</p>
      </div>

      <div id="results" style="margin-top:12px"></div>

      <!-- Barra de progreso grupal -->
      <div id="groupProgressContainer" class="hidden" style="margin-top:16px">
        <h4>Progreso Grupal</h4>
        <div style="display:flex;align-items:center;gap:10px">
          <div class="progress-wrap" style="flex:1">
            <div class="progress"><i id="groupProgressBar" style="width:0%"></i></div>
          </div>
          <div class="small mono" id="groupProgressText">0 / 30</div>
        </div>
        <p class="small">Progreso conjunto del equipo. ¡Trabajen juntos para llegar al nivel 30!</p>
        
        <!-- Controles de progreso grupal (solo para moderador) -->
        <div id="groupProgressControls" class="hidden" style="margin-top:12px">
          <div style="display:flex;gap:8px;margin-bottom:8px">
            <button id="addGroupPointBtn">+1 Punto</button>
            <button id="removeGroupPointBtn" class="ghost">-1 Punto</button>
          </div>
          
          <!-- Control para ajustar el nivel máximo -->
          <div class="max-level-controls">
            <span class="small">Nivel máximo:</span>
            <input type="number" id="maxLevelInput" min="1" max="100" value="30">
            <button id="setMaxLevelBtn" class="ghost">Aplicar</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer style="margin-top:14px" class="small">La primera persona en entrar será el <strong>Moderador</strong>. Torre: 30 niveles.</footer>
</div>

<div id="modalRoot" class="hidden"></div>

<script type="module">
/* -------------- Firebase + Auth + Firestore -------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
import {
  getFirestore, doc, setDoc, getDoc, onSnapshot, collection,
  updateDoc, deleteDoc, serverTimestamp, getDocs, addDoc, query, orderBy,
  writeBatch
} from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

/* ------- CONFIG ------- */
const firebaseConfig = {
  apiKey: "AIzaSyAlxBHSufZtVZ-Sko7Db5TDOuwerEJ67Wg",
  authDomain: "integracion-c3e71.firebaseapp.com",
  databaseURL: "https://integracion-c3e71.firebaseio.com",
  projectId: "integracion-c3e71",
  storageBucket: "integracion-c3e71.firebasestorage.app",
  messagingSenderId: "445727613761",
  appId: "1:445727613761:web:48708f0368cba79444f7c0",
  measurementId: "G-GSNV9BNP3W"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

/* ------- UI refs ------- */
const statusEl = document.getElementById("status");
const joinBtn = document.getElementById("joinBtn");
const leaveBtn = document.getElementById("leaveBtn");
const participantsList = document.getElementById("participantsList");
const moderatorControls = document.getElementById("moderatorControls");
const startVoteBtn = document.getElementById("startVoteBtn");
const closeGameBtn = document.getElementById("closeGameBtn");
const gamePhaseEl = document.getElementById("gamePhase");
const notificationsEl = document.getElementById("notifications");
const impostorNotice = document.getElementById("impostorNotice");
const eliminatedNotice = document.getElementById("eliminatedNotice");
const resultsEl = document.getElementById("results");
const modalRoot = document.getElementById("modalRoot");
const groupProgressContainer = document.getElementById("groupProgressContainer");
const groupProgressBar = document.getElementById("groupProgressBar");
const groupProgressText = document.getElementById("groupProgressText");
const groupProgressControls = document.getElementById("groupProgressControls");
const addGroupPointBtn = document.getElementById("addGroupPointBtn");
const removeGroupPointBtn = document.getElementById("removeGroupPointBtn");
const maxLevelInput = document.getElementById("maxLevelInput");
const setMaxLevelBtn = document.getElementById("setMaxLevelBtn");
const voteStatusPanel = document.getElementById("voteStatusPanel");
const voteStatusList = document.getElementById("voteStatusList");
const currentRoundDisplay = document.getElementById("currentRoundDisplay");

let currentUser = null;
let unsubParts = null, unsubRoom = null, unsubEvents = null, unsubVotes = null, unsubPrivate = null;
let localState = { participants: [], room: null };
const ROOM_ID = "room_main";
const LETTERS = "ABCDEFGHIJ".split("");
let MAX_GROUP_LEVEL = 30;
let processedEventIds = new Set();
let voteCheckInterval = null;
let currentVotingRound = 0;

/* ------- UI helpers ------- */
function setStatus(txt, isError=false){ statusEl.textContent = txt; statusEl.style.color = isError ? "#ff7b7b" : ""; }
function showNotification(txt){ notificationsEl.innerHTML = `<div class="small">${txt}</div>`; }
function showModal(html){ modalRoot.innerHTML = `<div class="modal-backdrop">${html}</div>`; modalRoot.classList.remove("hidden"); }
function closeModal(){ modalRoot.innerHTML = ""; modalRoot.classList.add("hidden"); }

/* ------- Firestore helpers ------- */
async function ensureRoomExists(){
  const roomRef = doc(db,"rooms",ROOM_ID);
  try{
    const snap = await getDoc(roomRef);
    if(!snap.exists()){
      await setDoc(roomRef, { phase:"lobby", round:0, createdAt: serverTimestamp(), groupLevel: 0, maxGroupLevel: MAX_GROUP_LEVEL });
      setStatus(`Sala "${ROOM_ID}" creada automáticamente.`);
    } else {
      const data = snap.data();
      if (data.maxGroupLevel) {
        MAX_GROUP_LEVEL = data.maxGroupLevel;
        maxLevelInput.value = MAX_GROUP_LEVEL;
      }
    }
    return true;
  }catch(e){
    console.error("ensureRoomExists error", e);
    setStatus("Error al asegurar sala: "+(e?.message||e), true);
    return false;
  }
}

/* ------- Render participantes ------- */
function renderParticipants(list){
  participantsList.innerHTML = "";
  list.sort((a,b)=>{
    if(a.isModerator && !b.isModerator) return -1;
    if(!a.isModerator && b.isModerator) return 1;
    return (a.letter||"").localeCompare(b.letter||"");
  }).forEach(p=>{
    const li = document.createElement("li");

    const left = document.createElement("div");
    left.className = "part-left";
    
    const displayName = p.customName || p.name || "Invitado";
    
    left.innerHTML = `
      <div class="part-row">
        <div style="display:flex;align-items:center;gap:8px">
          <strong>${displayName}</strong>
          <span class="small">(${p.isModerator ? "Moderador" : (p.letter || "?")})</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px">
          <div class="level-num mono">${typeof p.level === 'number' ? p.level : 0}</div>
        </div>
      </div>
    `;

    li.appendChild(left);

    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.alignItems = "center";
    right.style.gap = "8px";
    right.innerHTML = `<span class="badge">${p.alive===false ? 'fuera' : (p.isModerator ? 'moderador' : 'jugador')}</span>`;

    if (!p.isModerator && p.uid === currentUser?.uid) {
      const editBtn = document.createElement("button");
      editBtn.textContent = "Editar";
      editBtn.className = "ghost";
      editBtn.style.fontSize = "12px";
      editBtn.onclick = () => openNameEditor(p);
      right.appendChild(editBtn);
    }

    li.appendChild(right);
    participantsList.appendChild(li);
  });
}

/* ------- Actualizar panel de estado de votación ------- */
async function updateVoteStatusPanel() {
  const me = localState.participants.find(p => p.uid === currentUser?.uid);
  if (!me || !me.isModerator || localState.room?.phase !== 'voting') {
    voteStatusPanel.classList.add("hidden");
    return;
  }

  voteStatusPanel.classList.remove("hidden");
  
  // Actualizar display de ronda actual
  currentRoundDisplay.textContent = currentVotingRound;
  
  const alivePlayers = localState.participants.filter(p => 
    p.alive !== false && !p.isModerator
  );

  // Obtener estado de votación de todos los jugadores
  const voteStatusItems = [];
  
  for (const player of alivePlayers) {
    try {
      const privateDoc = await getDoc(doc(db, "rooms", ROOM_ID, "private", player.uid));
      const data = privateDoc.exists() ? privateDoc.data() : {};
      const hasVoted = data.lastVoteRound === currentVotingRound && data.lastVoteAt;
      
      voteStatusItems.push(`
        <div class="vote-status-item">
          <div style="display:flex;align-items:center;">
            <span>${player.customName || player.name} (${player.letter})</span>
            ${hasVoted ? '<span class="vote-checkmark">✅</span>' : ''}
          </div>
          <span class="vote-status-badge ${hasVoted ? 'voted' : 'pending'}">
            ${hasVoted ? 'Votó' : 'Pendiente'}
          </span>
        </div>
      `);
    } catch (e) {
      console.debug("Error checking vote status for", player.uid, e);
      voteStatusItems.push(`
        <div class="vote-status-item">
          <div style="display:flex;align-items:center;">
            <span>${player.customName || player.name} (${player.letter})</span>
          </div>
          <span class="vote-status-badge pending">Pendiente</span>
        </div>
      `);
    }
  }

  voteStatusList.innerHTML = voteStatusItems.join('');
}

/* ------- Resetear votos de todos los jugadores ------- */
async function resetAllVotes() {
  try {
    const batch = writeBatch(db);
    const privateDocs = await getDocs(collection(db, "rooms", ROOM_ID, "private"));
    
    privateDocs.forEach(docSnap => {
      const data = docSnap.data();
      if (data.role === 'player') {
        // Resetear solo los campos de voto, mantener el resto de la información
        batch.update(docSnap.ref, {
          lastVoteFor: null,
          lastVoteAt: null,
          lastVoteRound: -1
        });
      }
    });
    
    await batch.commit();
    console.log("Votos reseteados para todos los jugadores");
  } catch (e) {
    console.error("Error reseteando votos:", e);
  }
}

/* ------- Editor de nombre ------- */
function openNameEditor(player) {
  const html = `<div class="modal">
    <h4>Editar Nombre</h4>
    <div class="small">Personaliza tu nombre para que aparezca en el juego</div>
    <div style="margin-top:12px">
      <input type="text" id="nameInput" value="${player.customName || player.name || ''}" style="width:100%;padding:8px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:white" placeholder="Ingresa tu nombre">
    </div>
    <div style="margin-top:12px;display:flex;gap:8px">
      <button id="saveNameBtn">Guardar</button>
      <button id="cancelNameBtn" class="ghost">Cancelar</button>
    </div>
  </div>`;
  showModal(html);

  const saveBtn = modalRoot.querySelector("#saveNameBtn");
  const cancelBtn = modalRoot.querySelector("#cancelNameBtn");
  const nameInput = modalRoot.querySelector("#nameInput");

  saveBtn.onclick = async () => {
    const newName = nameInput.value.trim();
    if (newName) {
      try {
        await updateDoc(doc(db, "rooms", ROOM_ID, "participants", player.uid), {
          customName: newName
        });
        closeModal();
        setStatus("Nombre actualizado correctamente.");
      } catch (e) {
        console.error(e);
        setStatus("Error al actualizar nombre: " + (e?.message || e), true);
      }
    }
  };

  cancelBtn.onclick = () => closeModal();
}

/* ------- Actualizar barra de progreso grupal ------- */
function updateGroupProgress() {
  const groupLevel = localState.room?.groupLevel || 0;
  const progressPercent = Math.min(100, Math.round((groupLevel / MAX_GROUP_LEVEL) * 100));
  
  groupProgressBar.style.width = `${progressPercent}%`;
  groupProgressText.textContent = `${groupLevel} / ${MAX_GROUP_LEVEL}`;
  groupProgressContainer.classList.remove("hidden");
}

/* ------- Mostrar ventana de votación ------- */
function showVoteModal() {
  const me = localState.participants.find(p => p.uid === currentUser?.uid);
  
  // Solo mostrar ventana si el usuario es jugador, está vivo y no ha votado aún
  if (!me || me.isModerator || me.alive === false) {
    return;
  }

  // Verificar si ya votó en ESTA ronda
  getDoc(doc(db, "rooms", ROOM_ID, "private", currentUser.uid)).then(snap => {
    const data = snap.exists() ? snap.data() : {};
    
    // Si ya votó en esta ronda, no mostrar ventana
    if (data.lastVoteRound === currentVotingRound && data.lastVoteAt) {
      return;
    }

    // Crear ventana de votación
    const alivePlayers = localState.participants.filter(p => 
      p.alive !== false && p.uid !== currentUser.uid && !p.isModerator
    );

    if (alivePlayers.length === 0) {
      return;
    }

    let selectedPlayer = null;
    
    const html = `<div class="modal vote-modal">
      <h3>Votación Activa - Ronda ${currentVotingRound}</h3>
      <p class="small">Elige al rival más débil:</p>
      <div class="participant-list">
        ${alivePlayers.map(player => `
          <div class="participant-item" data-uid="${player.uid}">
            <div style="display:flex;align-items:center;justify-content:space-between">
              <div>
                <strong>${player.customName || player.name}</strong>
                <div class="small">${player.letter}</div>
              </div>
              <div class="level-num mono">${player.level || 0}</div>
            </div>
          </div>
        `).join('')}
      </div>
      <p class="small" style="margin-top:12px;color:var(--accent)">Tu voto es anónimo</p>
      <button id="confirmVoteBtn" class="vote-confirm" disabled>Confirmar Voto</button>
    </div>`;
    
    showModal(html);
    
    // Manejar selección de jugador
    const participantItems = modalRoot.querySelectorAll('.participant-item');
    participantItems.forEach(item => {
      item.addEventListener('click', () => {
        // Deseleccionar todos
        participantItems.forEach(i => i.classList.remove('selected'));
        // Seleccionar este
        item.classList.add('selected');
        selectedPlayer = item.dataset.uid;
        // Habilitar botón de confirmación
        modalRoot.querySelector('#confirmVoteBtn').disabled = false;
      });
    });
    
    // Manejar confirmación de voto
    modalRoot.querySelector('#confirmVoteBtn').addEventListener('click', async () => {
      if (!selectedPlayer) return;
      
      try {
        // Registrar voto en memoria de Firebase
        await updateDoc(doc(db, "rooms", ROOM_ID, "private", currentUser.uid), { 
          lastVoteFor: selectedPlayer, 
          lastVoteAt: serverTimestamp(),
          lastVoteRound: currentVotingRound
        });
        
        const playerName = alivePlayers.find(p => p.uid === selectedPlayer)?.customName || 
                          alivePlayers.find(p => p.uid === selectedPlayer)?.name;
        setStatus(`Has votado por ${playerName} en la ronda ${currentVotingRound}`);
        closeModal();
        
        // Actualizar panel de estado de votación
        updateVoteStatusPanel();
        
        // Verificar si todos han votado
        setTimeout(checkAllVoted, 1000);
      } catch (e) {
        console.error(e);
        setStatus("Error al votar: " + (e?.message || e), true);
      }
    });
  }).catch(e => {
    console.debug("Error checking vote status:", e);
  });
}

/* ------- Subscriptions ------- */
function subscribeParticipants(){
  const partsCol = collection(db,"rooms",ROOM_ID,"participants");
  if(unsubParts) unsubParts();
  unsubParts = onSnapshot(partsCol, snap=>{
    const parts = [];
    snap.forEach(d=>parts.push({ id:d.id, ...d.data() }));
    localState.participants = parts;
    renderParticipants(parts);
    updateLocalUI();
  }, err=>{
    console.error("participants listen", err);
    setStatus("Error al escuchar participantes: "+err.message, true);
  });
}

function subscribeRoom(){
  const roomRef = doc(db,"rooms",ROOM_ID);
  if(unsubRoom) unsubRoom();
  unsubRoom = onSnapshot(roomRef, snap=>{
    const oldRoom = localState.room;
    localState.room = snap.exists() ? snap.data() : null;
    gamePhaseEl.textContent = `Fase: ${localState.room?.phase || "-"} | Ronda: ${localState.room?.round || 0}`;
    
    // Actualizar el nivel máximo si está definido en Firestore
    if (localState.room?.maxGroupLevel) {
      MAX_GROUP_LEVEL = localState.room.maxGroupLevel;
      maxLevelInput.value = MAX_GROUP_LEVEL;
    }
    
    updateGroupProgress();
    updateLocalUI();

    // Detectar cambio a fase de votación
    const isNowVoting = localState.room?.phase === 'voting';
    const wasVoting = oldRoom?.phase === 'voting';
    
    if (isNowVoting && !wasVoting) {
      // Acabamos de entrar en fase de votación
      console.log("Cambio a fase de votación detectado");
      currentVotingRound = localState.room?.round || 0;
      
      // Iniciar verificación periódica de votos
      if (voteCheckInterval) clearInterval(voteCheckInterval);
      voteCheckInterval = setInterval(checkAllVoted, 3000);
      
      // Actualizar panel de estado de votación
      updateVoteStatusPanel();
      
      // Mostrar ventana de votación después de un pequeño delay para asegurar que los datos estén cargados
      setTimeout(() => {
        showVoteModal();
      }, 500);
    } else if (!isNowVoting && wasVoting) {
      // Salimos de la fase de votación - RESETEAR VOTOS
      console.log("Saliendo de fase de votación - Reseteando votos");
      resetAllVotes();
      
      if (voteCheckInterval) {
        clearInterval(voteCheckInterval);
        voteCheckInterval = null;
      }
      voteStatusPanel.classList.add("hidden");
    }
  }, err=>{
    console.error("room listen", err);
    setStatus("Error al escuchar sala: "+err.message, true);
  });
}

/* ------- Events subscription ------- */
function subscribeEvents(){
  const eventsCol = collection(db,"rooms",ROOM_ID,"events");
  const q = query(eventsCol, orderBy("createdAt","asc"));
  if(unsubEvents) unsubEvents();
  unsubEvents = onSnapshot(q, snap=>{
    snap.docChanges().forEach(change=>{
      if(change.type === "added"){
        const id = change.doc.id;
        if(processedEventIds.has(id)) return;
        processedEventIds.add(id);
        const ev = change.doc.data();
        handleEvent(ev, id);
      }
    });
  }, err=>{
    console.error("events listen", err);
  });
}

/* ------- Votes subscription ------- */
function subscribeVotes() {
  const votesCol = collection(db, "rooms", ROOM_ID, "votes");
  if (unsubVotes) unsubVotes();
  unsubVotes = onSnapshot(votesCol, async (snap) => {
    if (localState.room?.phase === 'voting') {
      await checkAllVoted();
      updateVoteStatusPanel();
    }
  }, err => {
    console.error("votes listen", err);
  });
}

/* ------- Private documents subscription ------- */
function subscribePrivateDocs() {
  if (unsubPrivate) unsubPrivate();
  const privateCol = collection(db, "rooms", ROOM_ID, "private");
  unsubPrivate = onSnapshot(privateCol, (snap) => {
    if (localState.room?.phase === 'voting') {
      updateVoteStatusPanel();
    }
  }, err => {
    console.debug("private docs listen:", err?.code || err);
  });
}

/* ------- Verificar si todos han votado ------- */
async function checkAllVoted() {
  try {
    const alivePlayers = localState.participants.filter(p => 
      p.alive !== false && !p.isModerator
    );

    if (alivePlayers.length === 0) {
      return;
    }
    
    // Contar votantes únicos consultando documentos privados (solo de esta ronda)
    const voters = new Set();
    const privateDocs = await getDocs(collection(db, "rooms", ROOM_ID, "private"));
    privateDocs.forEach(docSnap => {
      const data = docSnap.data();
      if (data.lastVoteAt && data.lastVoteRound === currentVotingRound && data.role === 'player') {
        voters.add(docSnap.id);
      }
    });
    
    console.log(`Votación: ${voters.size}/${alivePlayers.length} han votado en ronda ${currentVotingRound}`);
    
    // Si todos los jugadores vivos han votado, procesar automáticamente
    if (voters.size >= alivePlayers.length) {
      setStatus("Todos han votado. Procesando resultados automáticamente...");
      await endVotingAndEliminateWeakest();
    }
  } catch (e) {
    console.error("Error checking votes:", e);
  }
}

/* ------- Manejar eventos ------- */
function handleEvent(ev, id){
  if(!ev || !ev.type) return;
  if(ev.type === "startGame"){
    setStatus("Evento: Juego iniciado.");
    if(currentUser && ev.rivalUid === currentUser.uid){
      impostorNotice.classList.remove("hidden");
      document.getElementById("youAre").textContent = "¡Eres el rival más débil!";
    } else {
      impostorNotice.classList.add("hidden");
    }
    updateGroupProgress();
  } else if(ev.type === "startVote"){
    setStatus("Evento: Votación iniciada.");
    if (voteCheckInterval) clearInterval(voteCheckInterval);
    voteCheckInterval = setInterval(checkAllVoted, 3000);
    
    // Actualizar panel de estado de votación
    updateVoteStatusPanel();
    
    // Mostrar ventana de votación cuando se recibe el evento de inicio de votación
    setTimeout(() => {
      showVoteModal();
    }, 500);
  } else if(ev.type === "gameClosed"){
    setStatus("Evento: Juego cerrado por moderador.");
    impostorNotice.classList.add("hidden");
    eliminatedNotice.classList.add("hidden");
    
    // Resetear contador de ronda a 0
    currentVotingRound = 0;
    
    if (voteCheckInterval) {
      clearInterval(voteCheckInterval);
      voteCheckInterval = null;
    }
    voteStatusPanel.classList.add("hidden");
  } else if(ev.type === "votingEnded") {
    setStatus("Votación terminada. Resultados:");
    showNotification(`El rival más débil es: ${ev.weakestPlayerName}. Ha sido eliminado del juego.`);
    
    const weakestPlayer = localState.participants.find(p => p.uid === ev.weakestPlayerUid);
    if (weakestPlayer) {
      weakestPlayer.alive = false;
      renderParticipants(localState.participants);
      updateGroupProgress();
      
      // Mostrar aviso al usuario eliminado
      if (currentUser && currentUser.uid === ev.weakestPlayerUid) {
        eliminatedNotice.classList.remove("hidden");
        setStatus("¡Fuiste eliminado en esta ronda! Espera a que el moderador cierre el juego para volver a participar.");
      }
    }
    
    if (voteCheckInterval) {
      clearInterval(voteCheckInterval);
      voteCheckInterval = null;
    }
    voteStatusPanel.classList.add("hidden");
  } else if(ev.type === "groupLevelChanged") {
    updateGroupProgress();
  } else if(ev.type === "maxLevelChanged") {
    MAX_GROUP_LEVEL = ev.newMaxLevel;
    maxLevelInput.value = MAX_GROUP_LEVEL;
    updateGroupProgress();
    setStatus(`Nivel máximo cambiado a ${MAX_GROUP_LEVEL}`);
  }
}

/* ------- UI state updates ------- */
function updateLocalUI(){
  const alive = localState.participants.filter(p=>p.alive !== false);
  const me = localState.participants.find(p=>p.uid === currentUser?.uid);
  
  if(me){ 
    joinBtn.classList.add("hidden"); 
    leaveBtn.classList.remove("hidden"); 
    joinBtn.disabled = false; 
    
    // Verificar si el usuario actual fue eliminado
    if (me.alive === false) {
      eliminatedNotice.classList.remove("hidden");
      setStatus("¡Fuiste eliminado en esta ronda! Espera a que el moderador cierre el juego para volver a participar.");
    } else {
      eliminatedNotice.classList.add("hidden");
    }
  } else { 
    joinBtn.classList.remove("hidden"); 
    leaveBtn.classList.add("hidden"); 
    joinBtn.disabled = false; 
  }
  
  if(me && me.isModerator) {
    moderatorControls.classList.remove("hidden");
    groupProgressControls.classList.remove("hidden");
    // Mostrar panel de estado de votación si estamos en fase de votación
    if (localState.room?.phase === 'voting') {
      updateVoteStatusPanel();
    }
  } else {
    moderatorControls.classList.add("hidden");
    groupProgressControls.classList.add("hidden");
  }
  
  if(!me) {
    impostorNotice.classList.add("hidden");
    eliminatedNotice.classList.add("hidden");
  }
  
  if(localState.room?.phase === "ended") resultsEl.innerHTML = `<div class="small"><strong>Juego terminado.</strong></div>`; 
  else resultsEl.innerHTML = "";
  
  showNotification(`Conectados: ${alive.length} jugadores vivos. Total: ${localState.participants.length} / 11.`);
}

/* ------- Helpers de lobby ------- */
function nextAvailableLetter(){
  const used = localState.participants.map(p=>p.letter).filter(Boolean);
  for(const l of LETTERS) if(!used.includes(l)) return l;
  return null;
}
function isLobbyFull(){ return localState.participants.length >= 11; }

/* ------- Join ------- */
joinBtn.addEventListener("click", async ()=>{
  setStatus("Solicitando ingreso...");
  try{
    const ok = await ensureRoomExists();
    if(!ok) return;
    if(isLobbyFull()){ setStatus("Lobby lleno (1 moderador + 10 jugadores).", true); return; }

    const partsSnap = await getDocs(collection(db,"rooms",ROOM_ID,"participants"));
    const parts = []; partsSnap.forEach(d=>parts.push({ id:d.id, ...d.data() }));
    const hasModerator = parts.some(p=>p.isModerator);
    const usedLetters = parts.map(p=>p.letter).filter(Boolean);
    const partRef = doc(db,"rooms",ROOM_ID,"participants",currentUser.uid);

    if(!hasModerator){
      await setDoc(partRef, { uid: currentUser.uid, name: `Moderador`, letter: null, isModerator: true, alive: true, joinedAt: serverTimestamp(), level: 0 });
      await setDoc(doc(db,"rooms",ROOM_ID,"private",currentUser.uid), { role: "moderator" });
      setStatus("Ingresado como Moderador.");
    } else {
      let letter = null;
      for(const l of LETTERS) if(!usedLetters.includes(l)){ letter = l; break; }
      if(!letter){ setStatus("Lobby de jugadores lleno (A–J).", true); return; }
      await setDoc(partRef, { uid: currentUser.uid, name: `Jugador ${letter}`, letter, isModerator: false, alive: true, joinedAt: serverTimestamp(), level: 0 });
      await setDoc(doc(db,"rooms",ROOM_ID,"private",currentUser.uid), { 
        role: "player", 
        lastVoteFor: null, 
        lastVoteAt: null, 
        lastVoteRound: -1 
      });
      setStatus(`Ingresado como Jugador ${letter}.`);
    }
  }catch(e){ console.error(e); setStatus("Error al unirse: "+(e?.message || e), true); }
});

/* ------- Leave ------- */
leaveBtn.addEventListener("click", async ()=>{
  if(!confirm("¿Seguro que quieres salir?")) return;
  try{
    await deleteDoc(doc(db,"rooms",ROOM_ID,"participants",currentUser.uid));
    await deleteDoc(doc(db,"rooms",ROOM_ID,"private",currentUser.uid));
    setStatus("Has salido.");
  }catch(e){ console.error(e); setStatus("Error al salir: "+(e?.message || e), true); }
});

/* ------- Cambiar nivel grupal ------- */
addGroupPointBtn.addEventListener("click", async ()=>{
  try{
    const me = localState.participants.find(p=>p.uid === currentUser?.uid);
    if(!me || !me.isModerator){ alert("Solo el moderador puede cambiar el nivel grupal."); return; }
    
    const currentLevel = localState.room?.groupLevel || 0;
    const newLevel = Math.min(MAX_GROUP_LEVEL, currentLevel + 1);
    
    const roomRef = doc(db,"rooms",ROOM_ID);
    await updateDoc(roomRef, { groupLevel: newLevel });
    
    await addDoc(collection(db,"rooms",ROOM_ID,"events"), {
      type: "groupLevelChanged", newLevel, createdBy: currentUser.uid, createdAt: serverTimestamp()
    });
    
    setStatus(`Nivel grupal aumentado a ${newLevel}.`);
    updateGroupProgress();
  }catch(e){ console.error(e); setStatus("Error al cambiar nivel grupal: "+(e?.message||e), true); }
});

removeGroupPointBtn.addEventListener("click", async ()=>{
  try{
    const me = localState.participants.find(p=>p.uid === currentUser?.uid);
    if(!me || !me.isModerator){ alert("Solo el moderador puede cambiar el nivel grupal."); return; }
    
    const currentLevel = localState.room?.groupLevel || 0;
    const newLevel = Math.max(0, currentLevel - 1);
    
    const roomRef = doc(db,"rooms",ROOM_ID);
    await updateDoc(roomRef, { groupLevel: newLevel });
    
    await addDoc(collection(db,"rooms",ROOM_ID,"events"), {
      type: "groupLevelChanged", newLevel, createdBy: currentUser.uid, createdAt: serverTimestamp()
    });
    
    setStatus(`Nivel grupal reducido a ${newLevel}.`);
    updateGroupProgress();
  }catch(e){ console.error(e); setStatus("Error al cambiar nivel grupal: "+(e?.message||e), true); }
});

/* ------- Cambiar nivel máximo ------- */
setMaxLevelBtn.addEventListener("click", async ()=>{
  try{
    const me = localState.participants.find(p=>p.uid === currentUser?.uid);
    if(!me || !me.isModerator){ alert("Solo el moderador puede cambiar el nivel máximo."); return; }
    
    const newMaxLevel = parseInt(maxLevelInput.value);
    if(isNaN(newMaxLevel) || newMaxLevel < 1 || newMaxLevel > 100){
      alert("Por favor ingresa un número válido entre 1 y 100.");
      return;
    }
    
    MAX_GROUP_LEVEL = newMaxLevel;
    
    const roomRef = doc(db,"rooms",ROOM_ID);
    await updateDoc(roomRef, { maxGroupLevel: newMaxLevel });
    
    await addDoc(collection(db,"rooms",ROOM_ID,"events"), {
      type: "maxLevelChanged", newMaxLevel, createdBy: currentUser.uid, createdAt: serverTimestamp()
    });
    
    setStatus(`Nivel máximo cambiado a ${newMaxLevel}.`);
    updateGroupProgress();
  }catch(e){ console.error(e); setStatus("Error al cambiar nivel máximo: "+(e?.message||e), true); }
});

/* ------- Iniciar votación ------- */
startVoteBtn.addEventListener("click", async ()=>{
  try{
    const me = localState.participants.find(p=>p.uid === currentUser?.uid);
    if(!me || !me.isModerator){ alert("Solo el moderador puede iniciar la votación."); return; }

    const roomRef = doc(db,"rooms",ROOM_ID);
    const currentRound = (localState.room?.round || 0) + 1;
    
    try{
      await updateDoc(roomRef, { 
        phase: "voting", 
        round: currentRound,
        votingStartedAt: serverTimestamp() 
      });
      setStatus(`Votación iniciada - Ronda ${currentRound}`);
    }catch(upErr){
      await addDoc(collection(db,"rooms",ROOM_ID,"events"), {
        type: "startVote", 
        round: currentRound,
        createdBy: currentUser.uid, 
        createdAt: serverTimestamp()
      });
      setStatus(`Votación iniciada (evento creado) - Ronda ${currentRound}`);
    }

    if (voteCheckInterval) clearInterval(voteCheckInterval);
    voteCheckInterval = setInterval(checkAllVoted, 3000);
    
  }catch(e){ console.error(e); setStatus("Error al iniciar votación: "+(e?.message || e), true); }
});

/* ------- Finalizar votación automáticamente ------- */
async function endVotingAndEliminateWeakest() {
  try {
    // Obtener los votos de la memoria de Firebase (documentos privados)
    const privateDocs = await getDocs(collection(db, "rooms", ROOM_ID, "private"));
    const votes = [];
    
    privateDocs.forEach(docSnap => {
      const data = docSnap.data();
      if (data.lastVoteRound === currentVotingRound && data.lastVoteFor && data.role === 'player') {
        votes.push({
          targetUid: data.lastVoteFor,
          voterUid: docSnap.id
        });
      }
    });
    
    console.log(`Procesando ${votes.length} votos para la ronda ${currentVotingRound}`);
    
    const voteCount = {};
    votes.forEach(vote => {
      voteCount[vote.targetUid] = (voteCount[vote.targetUid] || 0) + 1;
    });
    
    let maxVotes = 0;
    let weakestPlayerUid = null;
    let weakestPlayerName = null;
    
    for (const [uid, count] of Object.entries(voteCount)) {
      if (count > maxVotes) {
        maxVotes = count;
        weakestPlayerUid = uid;
        const player = localState.participants.find(p => p.uid === uid);
        weakestPlayerName = player ? (player.customName || player.name) : "Desconocido";
      }
    }
    
    if (weakestPlayerUid) {
      await updateDoc(doc(db,"rooms",ROOM_ID,"participants",weakestPlayerUid), { alive: false });
      
      await addDoc(collection(db,"rooms",ROOM_ID,"events"), {
        type: "votingEnded", 
        weakestPlayerUid, 
        weakestPlayerName,
        voteCount: maxVotes,
        round: currentVotingRound,
        createdBy: currentUser.uid, 
        createdAt: serverTimestamp()
      });
      
      const roomRef = doc(db,"rooms",ROOM_ID);
      await updateDoc(roomRef, { phase: "playing" });
      
      setStatus(`Votación finalizada - Ronda ${currentVotingRound}. ${weakestPlayerName} ha sido eliminado.`);
    } else {
      setStatus("No se pudo determinar el rival más débil.");
    }
    
    // Los votos se resetearán automáticamente cuando salgamos de la fase de votación
    
    if (voteCheckInterval) {
      clearInterval(voteCheckInterval);
      voteCheckInterval = null;
    }
    
  } catch(e) {
    console.error(e);
    setStatus("Error al finalizar votación: "+(e?.message || e), true);
  }
}

/* ------- Cerrar juego ------- */
closeGameBtn.addEventListener("click", async ()=>{
  if(!confirm("¿Seguro que quieres cerrar el juego? Esto eliminará todos los datos de la partida actual.")) return;
  try{
    const me = localState.participants.find(p=>p.uid === currentUser?.uid);
    if(!me || !me.isModerator){ alert("Solo el moderador puede cerrar el juego."); return; }

    // Resetear contador de ronda a 0 en la sala
    const roomRef = doc(db,"rooms",ROOM_ID);
    await updateDoc(roomRef, { 
      phase: "lobby", 
      round: 0,  // RESETEAR CONTADOR DE RONDA
      rivalUid: null, 
      votingStartedAt: null, 
      groupLevel: 0 
    });

    // Resetear votos de todos los jugadores
    await resetAllVotes();

    // Eliminar todos los participantes
    const participantsSnap = await getDocs(collection(db,"rooms",ROOM_ID,"participants"));
    for (const docSnap of participantsSnap.docs) {
      await deleteDoc(doc(db,"rooms",ROOM_ID,"participants",docSnap.id));
    }

    // Eliminar todos los documentos privados
    const privateSnap = await getDocs(collection(db,"rooms",ROOM_ID,"private"));
    for (const docSnap of privateSnap.docs) {
      await deleteDoc(doc(db,"rooms",ROOM_ID,"private",docSnap.id));
    }

    // Eliminar todos los eventos
    const eventsSnap = await getDocs(collection(db,"rooms",ROOM_ID,"events"));
    for (const docSnap of eventsSnap.docs) {
      await deleteDoc(docSnap.ref);
    }

    await addDoc(collection(db,"rooms",ROOM_ID,"events"), {
      type: "gameClosed", createdBy: currentUser.uid, createdAt: serverTimestamp()
    });

    setStatus("Juego cerrado. Todos los datos han sido eliminados y el contador de ronda reseteado.");

    if (voteCheckInterval) {
      clearInterval(voteCheckInterval);
      voteCheckInterval = null;
    }

  }catch(e){ console.error(e); setStatus("Error al cerrar juego: "+(e?.message || e), true); }
});

/* ------- Auth flows y listeners ------- */
async function tryAnonSignIn(){
  setStatus("Intentando autenticación anónima...");
  try{ await signInAnonymously(auth); }
  catch(err){ console.error("anon sign-in err", err); setStatus("Error de autenticación anónima: " + (err.message || err.code), true); }
}

onAuthStateChanged(auth, async (user)=>{
  if(user){
    currentUser = user;
    setStatus("Conectado (anónimo). UID: " + user.uid);
    joinBtn.disabled = false;
    try{
      await ensureRoomExists();
      subscribeParticipants();
      subscribeRoom();
      subscribeEvents();
      subscribeVotes();
      subscribePrivateDocs();

      const privateRef = doc(db,"rooms",ROOM_ID,"private", user.uid);
      onSnapshot(privateRef, snap=>{
        // Actualizar ventana de votación si cambia el estado de voto
        if (localState.room?.phase === 'voting') {
          showVoteModal();
        }
      }, err=>{ console.debug("private listen:", err?.code || err); });

    }catch(e){ console.error(e); setStatus("Error suscribiendo: "+(e.message||e), true); }
  } else {
    setStatus("No autenticado (intento de anónimo automático).", true);
  }
});

/* ------- start auth ------- */
tryAnonSignIn();

</script>
</body>
</html>
